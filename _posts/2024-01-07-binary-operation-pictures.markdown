---
layout: post
page-type: post
title:  "Binary Operation Pictures"
date:   2024-01-07 14:55:00 -0800
tags: math
---
I thought it would be interesting to generate some pictures of binary operations.[^pics] As we all know, there are 256 shades of monochrome.[^mono] 256 also happens to be a nice side length for an image to have. So given a function $$f$$ that takes two natural numbers ranging from 0 (inclusive) to 256 (exclusive), a picture can be generated by coloring the pixel at $$(x, y)$$ the shade of monochrome corresponding to $$f(x, y)$$. That is, $$(f(x, y), f(x, y), f(x, y))$$. One caveat is that the origin is at the top-left and $$y$$ points down, as is standard for 2D graphics.

<p style="color: #c00;">Warning: At least one of the animations near the bottom contains flashing images.</p>

For example, here's addition mod 256, which is a diagonal gradient, as expected, and multiplication mod 256, which actually gives an interesting pattern:

<div class="figrow">
    <figure>
        <!--img src="/assets/posts/binary-operation-pictures/addition.png"/-->
        <fakecanvas fn="return (x + y) % 256u;"></fakecanvas>
        <figcaption>$$f(x, y) = \textrm{mod}(x + y, 256)$$</figcaption>
    </figure>
    <figure>
        <fakecanvas fn="return (x * y) % 256u;"></fakecanvas>
        <figcaption>$$f(x, y) = \textrm{mod}(x\times y, 256)$$</figcaption>
    </figure>
</div>

There are 4 classic arithmetic operations, so the other two should of course get pictures too. Subtraction is just flipped addition, and division has to be handled specially. If we just let $$f(x, y) = \lfloor x/y\rfloor$$, then most resulting values will be less than, say, 16, and half the values will be 0, making the picture almost completely black. To spice things up a bit, the result is multiplied by 256 so the full monochrome range can be used effectively. Let's also throw in a modulo picture for good measure.

<div class="figrow">
    <figure>
        <fakecanvas fn="return (x - y) % 256u;"></fakecanvas>
        <figcaption>$$f(x, y) = \textrm{mod}(x - y, 256)$$</figcaption>
    </figure>
    <figure>
        <fakecanvas fn="return y == 0u ? 0u : (256u * x / y) % 256u;"></fakecanvas>
        <figcaption>$$f(x, y) = \textrm{mod}(\lfloor 256x/y\rfloor, 256)$$</figcaption>
    </figure>
    <figure>
        <fakecanvas fn="return y == 0u ? 0u : (x % y);"></fakecanvas>
        <figcaption>$$f(x, y) = \textrm{mod}(x, y)$$</figcaption>
    </figure>
</div>

Bitwise operations can also be done. The pictures for those look kind of fractal-ish in some cases:

<div class="figrow">
    <figure>
        <fakecanvas fn="return x & y;"></fakecanvas>
        <figcaption>Bitwise AND: $$f(x, y) = x\ \&\ y$$</figcaption>
    </figure>
    <figure>
        <fakecanvas fn="return x | y;"></fakecanvas>
        <figcaption>Bitwise OR: $$f(x, y) = x\ |\ y$$</figcaption>
    </figure>
    <figure>
        <fakecanvas fn="return x ^ y;"></fakecanvas>
        <figcaption>Bitwise XOR: $$f(x, y) = x \oplus y$$</figcaption>
    </figure>
</div>

As a matter of fact, let's compare the result of bitwise AND to 0 and return 255 if equal and 0 otherwise. Let's do the same for bitwise OR, but compare to 255:

<div class="figrow">
    <figure>
        <fakecanvas fn="return (x & y) == 0u ? 255u : 0u;"></fakecanvas>
        <figcaption>$$f(x, y) = \cases{ 255 & $x\ \&\ y = 0$ \\ 0 & otherwise}$$</figcaption>
    </figure>
    <figure>
        <fakecanvas fn="return (x | y) == 255u ? 255u : 0u;"></fakecanvas>
        <figcaption>$$f(x, y) = \cases{ 255 & $x\ |\ y = 255$ \\ 0 & otherwise}$$</figcaption>
    </figure>
</div>

Oh look! It's a pair of right isosceles Sierpiński triangles! We can't really do the same thing for bitwise XOR, because you'd just get a boring white diagonal line against a boring black background, since $$x\oplus y = 0\implies x = y$$ (and $$x\oplus y = 255\implies x = 255 - y$$, since $$0\le x, y < 256$$). However, we *do* get something interesting by comparing it to $$\lfloor 256/3\rfloor = 01010101_2 = 85$$:

<div class="figrow">
    <figure>
        <fakecanvas fn="return (x ^ y) == 85u ? 255u : 0u;"></fakecanvas>
        <figcaption>$$f(x, y) = \cases{ 255 & $x \oplus y = 85$ \\ 0 & otherwise}$$</figcaption>
    </figure>
</div>

A Cantor set with aspect ratio 2! Changing this equals sign to a less-than sign also gives something interesting:

<div class="figrow">
    <figure>
        <fakecanvas fn="return (x ^ y) < 85u ? 255u : 0u;"></fakecanvas>
        <figcaption>$$f(x, y) = \cases{ 255 & $x \oplus y < 85$ \\ 0 & otherwise}$$</figcaption>
    </figure>
</div>

We can animate the value being compared to, resulting in some cool animations. Let $$t$$ be the current frame of the animation. It goes from 0 to 255 and loops back around.

<div class="figrow">
    <figure>
        <fakecanvas animate fn="return (x & y) == t ? 255u : 0u;"></fakecanvas>
        <figcaption>$$f(x, y) = \cases{ 255 & $x\ \&\ y = t$ \\ 0 & otherwise}$$</figcaption>
    </figure>
    <figure>
        <fakecanvas animate fn="return (x ^ y) == t ? 255u : 0u;"></fakecanvas>
        <figcaption>$$f(x, y) = \cases{ 255 & $x \oplus y = t$ \\ 0 & otherwise}$$</figcaption>
    </figure>
</div>

A flickering gliding Sierpiński triangle and a parameterized Cantor set! While animations are running, let's also show some animations involving ternary operations.[^binary]

<div class="figrow">
    <figure>
        <fakecanvas animate fn="return (x + y + t) % 256u;"></fakecanvas>
        <figcaption>$$f(x, y) = \textrm{mod}(x + y + t, 256)$$</figcaption>
    </figure>
    <figure>
        <fakecanvas animate fn="return (x * y * t) % 256u;"></fakecanvas>
        <figcaption>$$f(x, y) = \textrm{mod}(x\times y\times t, 256)$$</figcaption>
    </figure>
</div>

Let's not forget bitwise operations.

<div class="figrow">
    <figure>
        <fakecanvas animate fn="return x & y & t;"></fakecanvas>
        <figcaption>$$f(x, y) = x\ \&\ y\ \&\ t$$</figcaption>
    </figure>
    <figure>
        <fakecanvas animate fn="return x ^ y ^ t;"></fakecanvas>
        <figcaption>$$f(x, y) = x\oplus y\oplus t$$</figcaption>
    </figure>
</div>

[^pics]: If the pictures display weird, it's because I'm using a trick that fakes drawing to multiple HTML canvases using one WebGL2 rendering context. There's a [browser limit of 8 contexts (16 on desktop)](https://github.com/greggman/virtual-webgl#what), and rendering to an offscreen canvas and using drawImage() to copy to a real 2D canvas is [extremely slow on Firefox](https://bugzilla.mozilla.org/show_bug.cgi?id=1163426). [The trick](https://webgl2fundamentals.org/webgl/lessons/webgl-multiple-views.html) involves rendering a screenwide canvas on top of everything, scrolling it to the appropriate position as the user scrolls, and drawing on it exactly where the fake canvases are.

[^mono]: In classic 8-bit-per-channel encoding. There's also 16-bit-per-channel and float encoding, but I'm not using that here as the pictures would be come unnecessarily way too big.

[^binary]: The post title says "binary", but that assumes a static image :)

<script type="module" src="{{ '/assets/posts/binary-operation-pictures/render.js' | relative_url }}"></script>
